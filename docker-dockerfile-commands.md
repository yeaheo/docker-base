## Dockerfile 相关命令

### FROM 指定基础镜像
- 基础镜像其实就是以一个镜像作为基础，在其上进行定制。在定制镜像的时候要求我们选取最合适的镜像作为基础镜像，这样不仅方便我们后期分发镜像，而且制作的镜像也不会太臃肿。
- 例如：我们运行 java 程序的镜像一般选取 jre-alpine 这个镜像作为基础，这个镜像不仅体积小而且容易定制。除了选择现有基础镜像外，还有一种镜像叫做 scratch ，这个镜像其实是一种虚拟的概念，实际上并不存在，它代表了一个空白镜像。

### MAINTAINER 记录相关人员信息

- 例如：
  
  ```bash
  MAINTAINER Lv Xiaoteng <helleo.cn@gmail.com>
  ```

### RUN 执行命令

- RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：
  
  ```bash
  shell 格式：
  RUN <命令>

  exec 格式：
  RUN ["可执行文件","参数1","参数2"...]
  ```

- Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层,在其上执行这些命令，执行结束后, commit 这一层的修改，构成新的镜像。
  
  > 在执行 RUN 命令时，建议将多次 RUN 的命令合并为一层命令，这就需要灵活运用 “\” 和 “&&”。

- 构建镜像用 `docker build ` 命令，其格式如下：
  
  ```bash
  docker build [选项] <上下文路径/URL/->
  ``` 
- <上下文路径/URL/-> 指构建镜像时的上下文路径，我们通常将 dockerfile 放在一个单独的目录下，构建镜像时这个上下文路径就变成了 "." 。当构建镜像的时候，用户会指定构建镜像上下文的路径， `docker build` 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

  > 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore` ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。实际上 Dockerfile 的文件名并不要求必须为 Dockerfile ，而且并不要求必须位于上下文目录中，可以用 `-f` 参数指定。

### COPY 复制文件

- 当需要复制文件到镜像中的时候，我们一般用 COPY 命令，其具体格式如下：

  ```bash
  COPY <源路径>... <目标路径>
  COPY ["<源路径1>",... "<目标路径>"]
  ```
- 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路
径> 位置，<源路径> 可以是多个，甚至可以是通配符。例如：

  ```bash
  COPY hom* /mydir/
  COPY hom?.txt /mydir/
  ```
  > 使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。

### ADD 更高级的复制文件

- ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。
- 比如 <源路径> 可以是一个 URL ，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <目标路径> 去。下载后的文件权限自动设置为 600 ，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并
不实用，而且不推荐使用。

- 如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 <目标路径> 去。

- 当复制文件的时候尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。另外需要注意的是， ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。

  > 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。

### CMD 容器启动命令

- CMD 指令的格式和 RUN 相似，也是两种格式：
  
  ```bash
  shell 格式： CMD <命令>

  exec 格式： CMD ["可执行文件", "参数1", "参数2"...]

  参数列表格式： CMD ["参数1", "参数2"...] 。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。
  ```
- 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 " ，而不要使用单引号。如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。

### ENTRYPOINT 入口点

- ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。
- ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。
- 当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：
  
  ```bash
  <ENTRYPOINT> "<CMD>"
  ```
- ENTRYPOINT 的使用场景有两种：
  
  ```bash
  场景一： 让镜像变成像命令一样使用
  场景二： 应用运行前的准备工作
  ```

### ENV 设置环境变量

- ENV 格式有两种：
  
  ```bash
  ENV <key> <value>
  ENV <key1>=<value1> <key2>=<value2>...
  ```
- 当我们需要换行时用 `\` 即可，当变量中存在空格时，需要用双引号即可。
- 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。

### ARG 构建参数

- 构建参数格式：

  ```bash
  格式：ARG <参数名>[=<默认值>]
  ```
- 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 `docker history ` 还是可以看到所有值的。这个参数可以在构建命令 `docker build` 中用 `--build-arg <参数名>=<值>` 覆盖掉。
- 在 docker `1.13` 之前的版本，要求 `--build-arg` 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 `--build-arg` 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 `1.13` 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 `CI` 系统，用同样的构建流程构建不同的 `Dockerfile` 的时候比较有帮助，避免构建命令必须根据每个 `Dockerfile` 的内容修改。

### VOLUME 定义匿名卷

- 当容器运行时我们尽量不要在容器存储层写入任何东西，这样不仅造成容器臃肿，而且在一定程度上影响了容器的正常使用。我们可以通过挂载数据卷的方式解决这个问题，这样容器就不会在其存储层写入数据了，例如：

  ```bash
  VOLUME /data
  ```
- 这里的 `/data` 目录就会在运行时自动挂载为匿名卷，任何向 `/data` 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。
- 这个匿名卷也可以在容器启动时用 `-v` 选项覆盖掉：
  
  ```bash
  docker run -d -P -v mydata:/data nginx:latest
  ```

### EXPOSE 暴漏服务端口

- 每个镜像几乎都有对应的应用，当启动容器的时候i，镜像里的应用就会起作用，而且每个应用都有自己的服务端口，我们在 dockerfile 文件中，可以将服务端口用 EXPOSE 声明。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。

  ```bash
  EXPOSE 8080
  ```

- **WORKDIR 指定工作目录**
- 格式：

  ```bash
  WORKDIR <工作目录路径>。
  ```

- 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。

### USER 指定当前用户

- 格式：

  ```bash
  USER <用户名>
  ```

- USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。
- 和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。

### HEALTHCHECK 健康检查

- Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。
- 格式：

  ```bash
  HEALTHCHECK [选项] CMD <命令>      # 设置检查容器健康状况的命令
  HEALTHCHECK NONE                  # 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
  ```

- 健康检查有几个参数，如下：

  ```bash
  --interval=<间隔>      # 两次健康检查的间隔，默认为 30 秒；
  --timeout=<时长>       # 健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；
  --retries=<次数>       # 当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。
  ```
- 在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。
- 我们通常用如下命令做健康检查：

  ```bash
  curl -fs http://localhost/ || exit 1
  ```

- 完整 HEALTHCHECK 命令参考如下：

  ```bash
  HEALTHCHECK --interval=5s --timeout=3s \
    CMD curl -fs http://localhost/ || exit 1
  ```

### ONBUILD 为他人做嫁衣裳

- 格式：

  ```bash
  ONBUILD <其它指令>
  ```
- ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。
- Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。

### Dockerfile 参考文档
- Dockerfile 官方文档： <https://docs.docker.com/engine/reference/builder/>
- Dockerfile 最佳实践： <https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/>
- Docker 官方镜像 Dockerfile： <https://github.com/docker-library/docs>
