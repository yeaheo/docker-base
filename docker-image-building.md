## Docker - 构建镜像

### 利用 commit 理解镜像构成

- 镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础。镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。
- 当我们运行一个容器的时候（使用卷），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 `docker commit` 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。
- `docker commit` 的语法格式为：
  
  ```bash
  docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
  ```
- 例如，当我们修改了 nginx 镜像的时候可以用如下命令制作新镜像，这里只做参考：
  
  ```bash
  docker commit \
    --author "Lv Xiaoteng <helleo.cn@gmail.com>" \
    --message "修改了默认网页" \
    webserver \
    nginx:v2
  ```
- 其中 `--author` 是指定修改的作者，而 `--message` 则是记录本次修改的内容。这点和 `git` 版本控制相似，不过这里这些信息可以省略留空。

- 我们可以通过 `docker diff` 命令看到具体的改动，这里不再赘述。
- 实际状况下，我们制作镜像的时候不会用到 `docker commit` 而是用 dockerfile 的方式制作我们需要的镜像。 因为 `docker commit` 制作的镜像是在基本镜像的基础上直接保存容器存储层，这就造成了制作的镜像相当的臃肿，而且其他人也不知道镜像做了哪些更改，安装了哪些软件等等，可以说用 `docker commit` 制作的镜像是 **黑箱镜像** ，维护起来是相当的困难，所以我们不提倡用这种方式制作镜像，这里提到只是为了通过 `docker commit`了解镜像的构成。

### 利用 Dockerfile 制作镜像
- Dockerfile 其实是一种文本文件，其中包含了一条条指令，每个指令构建一层。因此每一条指令的内容，就是描述该层应当如何构建。

#### Dockerfile 相关命令

- **FROM 指定基础镜像**
- 基础镜像其实就是以一个镜像作为基础，在其上进行定制。在定制镜像的时候要求我们选取最合适的镜像作为基础镜像，这样不仅方便我们后期分发镜像，而且制作的镜像也不会太臃肿。
- 例如：我们运行 java 程序的镜像一般选取 jre-alpine 这个镜像作为基础，这个镜像不仅体积小而且容易定制。除了选择现有基础镜像外，还有一种镜像叫做 scratch ，这个镜像其实是一种虚拟的概念，实际上并不存在，它代表了一个空白镜像。

- **RUN 执行命令**
- RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：
  
  ```bash
  shell 格式：
  RUN <命令>

  exec 格式：
  RUN ["可执行文件","参数1","参数2"...]
  ```

- Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层,在其上执行这些命令，执行结束后, commit 这一层的修改，构成新的镜像。
  
  > 在执行 RUN 命令时，建议将多次 RUN 的命令合并为一层命令，这就需要灵活运用 “\” 和 “&&”。

- 构建镜像用 `docker build ` 命令，其格式如下：
  
  ```bash
  docker build [选项] <上下文路径/URL/->
  ``` 
- <上下文路径/URL/-> 指构建镜像时的上下文路径，我们通常将 dockerfile 放在一个单独的目录下，构建镜像时这个上下文路径就变成了 "." 。当构建镜像的时候，用户会指定构建镜像上下文的路径， `docker build` 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

  > 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 `.gitignore` 一样的语法写一个 `.dockerignore` ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。实际上 Dockerfile 的文件名并不要求必须为 Dockerfile ，而且并不要求必须位于上下文目录中，可以用 `-f` 参数指定。

- **COPY 复制文件**
- 当需要复制文件到镜像中的时候，我们一般用 COPY 命令，其具体格式如下：

  ```bash
  COPY <源路径>... <目标路径>
  COPY ["<源路径1>",... "<目标路径>"]
  ```
- 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路
径> 位置，<源路径> 可以是多个，甚至可以是通配符。例如：

  ```bash
  COPY hom* /mydir/
  COPY hom?.txt /mydir/
  ```
  > 使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。

- **ADD 更高级的复制文件**
- ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。
- 比如 <源路径> 可以是一个 URL ，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <目标路径> 去。下载后的文件权限自动设置为 600 ，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并
不实用，而且不推荐使用。

- 如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 <目标路径> 去。

- 当复制文件的时候尽可能的使用 COPY ，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。另外需要注意的是， ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。

  > 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。

- **CMD 容器启动命令**
- CMD 指令的格式和 RUN 相似，也是两种格式：
  
  ```bash
  shell 格式： CMD <命令>

  exec 格式： CMD ["可执行文件", "参数1", "参数2"...]

  参数列表格式： CMD ["参数1", "参数2"...] 。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。
  ```
- 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 " ，而不要使用单引号。如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。

- **ENTRYPOINT 入口点**
- ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。
- ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。 ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。
- 当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：
  
  ```bash
  <ENTRYPOINT> "<CMD>"
  ```
- ENTRYPOINT 的使用场景有两种：
  
  ```bash
  场景一： 让镜像变成像命令一样使用
  场景二： 应用运行前的准备工作
  ```

- **ENV 设置环境变量**
- ENV 格式有两种：
  
  ```bash
  ENV <key> <value>
  ENV <key1>=<value1> <key2>=<value2>...
  ```
- 当我们需要换行时用 `\` 即可，当变量中存在空格时，需要用双引号即可。
- 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。

